<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Live Translate (Speaker)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 900px; margin: 24px auto; }
    button { padding: 10px 16px; font-size: 16px; }
    #out { white-space: pre-wrap; border: 1px solid #ddd; padding: 12px; border-radius: 8px; min-height: 100px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    label { font-weight: 600; }
    select, input { font-size: 16px; padding: 6px 8px; }
    .muted { color: #666; font-size: 14px; }
    .final { font-weight: 600; }
    details { margin-top: 16px; }
    #log { height: 220px; overflow:auto; background:#0b1020; color:#e8f0ff; padding:10px; border-radius:8px; font: 12px/1.4 ui-monospace, Menlo, Consolas, monospace; }
    .stat { display:inline-block; margin-right:10px; }
  </style>
</head>
<body>
  <h1>Live Translate (Speaker)</h1>

  <div class="row">
    <label for="pair">Language Pair</label>
    <select id="pair">
  <option value="id-en">Indonesia ‚Üí English</option>
  <option value="en-id">English ‚Üí Indonesia</option>
  <option value="id-ja">Indonesia ‚Üí Êó•Êú¨Ë™û</option>
  <option value="ja-id">Êó•Êú¨Ë™û ‚Üí Indonesia</option>

  <option value="id-ko">Indonesia ‚Üí ÌïúÍµ≠Ïñ¥</option>
  <option value="ko-id">ÌïúÍµ≠Ïñ¥ ‚Üí Indonesia</option>

  <option value="id-ar">Indonesia ‚Üí ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
  <option value="ar-id">ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ‚Üí Indonesia</option>

   <!-- Mandarin / Chinese -->
  <option value="id-zh">Indonesia ‚Üí ‰∏≠Êñá</option>
  <option value="zh-id">‰∏≠Êñá ‚Üí Indonesia</option>

  <option value="id-de">Indonesia ‚Üí Deutsch</option>
  <option value="de-id">Deutsch ‚Üí Indonesia</option>

  <option value="id-fr">Indonesia ‚Üí Fran√ßais</option>
  <option value="fr-id">Fran√ßais ‚Üí Indonesia</option>

  <option value="id-nl">Indonesia ‚Üí Nederlands</option>
  <option value="nl-id">Nederlands ‚Üí Indonesia</option>

  <option value="id-ru">Indonesia ‚Üí –†—É—Å—Å–∫–∏–π</option>
  <option value="ru-id">–†—É—Å—Å–∫–∏–π ‚Üí Indonesia</option>

  <option value="id-es">Indonesia ‚Üí Espa√±ol</option>
  <option value="es-id">Espa√±ol ‚Üí Indonesia</option>
</select>


    <label for="name">Name</label>
    <input id="name" placeholder="Nama kamu" value="Speaker" />
  </div>

  <p class="muted">Share link viewer: <a id="share" href="#" target="_blank">(menunggu room‚Ä¶)</a></p>

  <div class="row">
    <button id="btn">üéôÔ∏è Start Speak</button>
    <span id="state" class="muted">idle</span>
  </div>

  <h3>Output</h3>
  <div id="out"></div>

  <details open>
    <summary><strong>Debug</strong></summary>
    <div class="muted" style="margin:6px 0 8px;">
      <span id="wsStat" class="stat">WS:-</span>
      <span id="sseStat" class="stat">SSE:-</span>
      <span id="micStat" class="stat">Mic:-</span>
    </div>
    <pre id="log"></pre>
  </details>




<script>
  let room = null;
  let ws = null;
  let es = null;
  let audioCtx = null;
  let workletNode = null;
  let mediaStream = null;
  let speaking = false;
  let commitTimer = null;

  // trackers
  let esState = "-";
  let chunksSent = 0;
  let bytesSent = 0;
  let bytesSinceCommit = 0;
  let commitsSent = 0;
  let lastCommitAt = 0;
  let watchdog = null;

  // === NEW: config dinamis (fallback kalau /config tak ada) ===
  const BYTES_PER_SAMPLE = 2;
  const COMMIT_MS_MIN = 100; // syarat server: >=100ms
  let CFG = { targetHz: 24000, batchMs: 120 };
  let MIN_COMMIT_BYTES = Math.round(CFG.targetHz * COMMIT_MS_MIN / 1000) * BYTES_PER_SAMPLE;

  async function loadConfig() {
    try {
      const r = await fetch("/config", { cache: "no-store" });
      if (!r.ok) throw new Error("config http " + r.status);
      const c = await r.json();
      if (![16000, 24000, 48000].includes(c.targetHz)) c.targetHz = 24000;
      c.batchMs = Math.max(100, +c.batchMs || 120);
      CFG = c;
      // Sambil nunggu worklet kirim 'config', set threshold awal berdasar target ENV
      MIN_COMMIT_BYTES = Math.round(CFG.targetHz * COMMIT_MS_MIN / 1000) * BYTES_PER_SAMPLE;
      dlog("config", CFG, "MIN_COMMIT_BYTES", MIN_COMMIT_BYTES);
    } catch (e) {
      dlog("config fallback", e?.message || e);
    }
  }

  const VAD_THRESH = 300;
  let vadActive = false;
  let vadHangFrames = 0;
  const VAD_HANG = 6;

  const out = document.getElementById("out");
  const btn = document.getElementById("btn");
  const stateEl = document.getElementById("state");
  const shareA = document.getElementById("share");
  const pairSel = document.getElementById("pair");
  const nameInput = document.getElementById("name");
  const wsStat = document.getElementById("wsStat");
  const sseStat = document.getElementById("sseStat");
  const micStat = document.getElementById("micStat");
  const logEl = document.getElementById("log");

  pairSel.addEventListener("change", () => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: "init",
        name: nameInput.value || "Speaker",
        pair: pairSel.value
      }));
    }
  });

  function fmt(v){try{return typeof v==="object"?JSON.stringify(v):String(v)}catch{return String(v)}}
  function dlog(...args){
    const t=new Date().toLocaleTimeString("en-GB",{hour12:false});
    logEl.textContent+=`[${t}] ${args.map(fmt).join(" ")}\n`;
    if(logEl.textContent.length>120000)logEl.textContent=logEl.textContent.slice(-80000);
    logEl.scrollTop=logEl.scrollHeight
  }

  function logLine(txt, cls) {
    const p = document.createElement("div");
    if (cls) p.className = cls;
    p.textContent = txt;
    out.appendChild(p);
    out.scrollTop = out.scrollHeight;
  }
  function renderPair(srcText, tgtText) {
    const last = out.lastElementChild;
    if (last && !last.classList.contains("final")) out.removeChild(last);
    const wrap = document.createElement("div"); wrap.className = "final";
    const line1 = document.createElement("div"); line1.textContent = srcText;
    const line2 = document.createElement("div"); line2.style.fontWeight = "700"; line2.textContent = tgtText;
    wrap.appendChild(line1); wrap.appendChild(line2);
    out.appendChild(wrap);
    out.scrollTop = out.scrollHeight;
  }

  function renderStats() {
    const wsMap = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    wsStat.textContent = `WS:${ws ? wsMap[ws.readyState] : "-"}`;
    sseStat.textContent = `SSE:${esState}`;
    const kb = (bytesSent / 1024).toFixed(1);
    const since = lastCommitAt ? (((Date.now() - lastCommitAt) / 1000).toFixed(1) + "s") : "-";
    micStat.textContent = `Mic:${speaking ? "on" : "off"}  chunks:${chunksSent}  bytes:${kb}KB  commits:${commitsSent} (last ${since})`;
  }
  setInterval(renderStats, 400);

  function armWatchdog(){clearWatchdog();watchdog=setTimeout(()=>{logLine("‚ö†Ô∏è Delay: tidak ada respons dari model (>2s).","final");dlog("watchdog timeout");},2000)}
  function clearWatchdog(){if(watchdog){clearTimeout(watchdog);watchdog=null}}

  async function createRoom() {
    dlog("POST /api/room ‚Ä¶");
    const resp = await fetch("/api/room", { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify({}) });
    const data = await resp.json();
    room = data.room_id;
    shareA.textContent = data.share_url;
    shareA.href = data.share_url;
    dlog("room created", room, "share:", data.share_url);

    // SSE subscribe
    es = new EventSource(`/sse/${room}`);
    esState = "connecting";
    es.onopen  = () => { esState = "open";  dlog("SSE open"); };
    es.onerror = (e) => { esState = "error"; dlog("SSE error", e?.message || ""); };
    es.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === "partial") {
          clearWatchdog();
          stateEl.textContent = "receiving‚Ä¶";
          const last = out.lastElementChild;
          if (last && !last.classList.contains("final")) last.textContent = msg.text;
          else logLine(msg.text);
        } else if (msg.type === "final") {
          clearWatchdog();
          stateEl.textContent = speaking ? "recording" : "idle";
          try {
            const obj = JSON.parse(msg.text);
            if (obj && typeof obj === "object" && "src" in obj && "tgt" in obj) {
              renderPair(obj.src, obj.tgt);
            } else {
              logLine(msg.text, "final");
            }
          } catch { logLine(msg.text, "final"); }
        } else if (msg.type === "error") {
          clearWatchdog();
          logLine("[error] " + JSON.stringify(msg.data), "final");
          dlog("SSE payload error", msg.data);
        }
      } catch (err) { dlog("SSE parse error", err?.message || err); }
    };


    // WS ke server (wajib supaya audio terkirim)
ws = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws/${room}`);

btn.disabled = true;
ws.addEventListener("open", () => {
  dlog("WS open");
  const pair = pairSel.value;
  const name = nameInput.value || "Speaker";
  ws.send(JSON.stringify({ type: "init", name, pair }));
  btn.disabled = false;
  stateEl.textContent = "ws ready";
});

ws.addEventListener("close", (ev) => dlog("WS close", `code=${ev.code}`, `reason=${ev.reason}`));
ws.addEventListener("error", (err) => dlog("WS error", err?.message || "unknown"));
ws.addEventListener("message", (ev) => {
  try {
    const m = JSON.parse(ev.data);
    if (m.error) {
      dlog("WS upstream error:", m.error);
      logLine("[upstream error] " + m.error, "final");
    }
  } catch {}
});

  }

  async function startAudio() {
    stateEl.textContent = "requesting mic‚Ä¶";
    await loadConfig();

    dlog("getUserMedia‚Ä¶");
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        channelCount: 1,
        sampleRate: 48000,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: false
      },
      video: false
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    dlog("AudioContext @", audioCtx.sampleRate, "Hz");
   
   
    await audioCtx.audioWorklet.addModule("/static/pcm-worklet.js?v=2"); // cache-buster


    await audioCtx.resume();

    const source = audioCtx.createMediaStreamSource(mediaStream);

    // === pakai selectable + target dari config ===
    workletNode = new AudioWorkletNode(audioCtx, "pcm16-selectable", {
     numberOfInputs: 1,
   numberOfOutputs: 1,         // <-- beri 1 output
  outputChannelCount: [1],    // mono keluar (silent)
  channelCount: 1,            // input mono
  channelCountMode: "explicit",
    processorOptions: { targetHz: CFG.targetHz, batchMs: CFG.batchMs }
  });

    // === UPDATED: tangani pesan object dari worklet ===
    workletNode.port.onmessage = (e) => {
      const msg = e.data || {};

      if (msg.type === "config") {
        // sesuaikan commit threshold ke outHz aktual dari worklet
        MIN_COMMIT_BYTES = Math.round(msg.outHz * COMMIT_MS_MIN / 1000) * BYTES_PER_SAMPLE;
        dlog("worklet config", msg, "MIN_COMMIT_BYTES", MIN_COMMIT_BYTES);
        return;
      }
      if (msg.type === "warn") {
        dlog("worklet warn", msg.message || "");
        return;
      }
      if (msg.type !== "pcm" || !msg.pcm) return;

      // Hanya kirim bagian valid (samples * 2 byte)
      const u8 = new Uint8Array(msg.pcm, 0, msg.samples * BYTES_PER_SAMPLE);
      const i16 = new Int16Array(msg.pcm, 0, msg.samples);

      // VAD RMS
      let sum = 0;
      for (let i = 0; i < i16.length; i++) { const s = i16[i]; sum += s * s; }
      const rms = Math.sqrt(sum / Math.max(1, i16.length));

      if (rms >= VAD_THRESH) {
        vadActive = true;
        vadHangFrames = VAD_HANG;
      } else if (vadHangFrames > 0) {
        vadHangFrames--;
        vadActive = true;
      } else {
        vadActive = false;
      }

      // Kirim hanya saat aktif bicara
      if (ws && ws.readyState === WebSocket.OPEN && vadActive) {
        ws.send(u8);
        const bytes = u8.byteLength || 0;
        chunksSent++;
        bytesSent += bytes;
        bytesSinceCommit += bytes;
        if (chunksSent % 20 === 0) dlog("audio chunk", `${bytes}B`, `total=${(bytesSent/1024).toFixed(1)}KB`, `rms=${rms|0}`);
      }
    };

    // mute to avoid echo
    const mute = audioCtx.createGain();
    mute.gain.value = 0;
    source.connect(workletNode);
    workletNode.connect(mute).connect(audioCtx.destination);

    // reset counters
    bytesSinceCommit = 0;
    commitsSent = 0;

    // periodic commit only when ‚â• ~100ms audio & user in pause
    commitTimer = setInterval(() => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (vadActive) return;
      if (bytesSinceCommit < MIN_COMMIT_BYTES) return;

      dlog('client commit', `bytesSinceCommit=${bytesSinceCommit}`);
      ws.send(JSON.stringify({ type: 'commit' }));
      commitsSent++; lastCommitAt = Date.now();
      bytesSinceCommit = 0;
      armWatchdog();
    }, 500);

    speaking = true;
    stateEl.textContent = "recording";
    btn.textContent = "‚èπ Stop";
    dlog("recording ON");
  }

  function stopAudio() {
    speaking = false;
    stateEl.textContent = "idle";
    btn.textContent = "üéôÔ∏è Start Speak";

    if (commitTimer) { clearInterval(commitTimer); commitTimer = null; }
    if (ws && ws.readyState === WebSocket.OPEN && bytesSinceCommit >= MIN_COMMIT_BYTES) {
      ws.send(JSON.stringify({ type: "commit" }));
      commitsSent++; lastCommitAt = Date.now();
      dlog("final commit");
      armWatchdog();
    }
    bytesSinceCommit = 0;
    clearWatchdog();

    try { workletNode && workletNode.disconnect(); } catch {}
    try { audioCtx && audioCtx.close(); } catch {}
    if (mediaStream) { for (const t of mediaStream.getTracks()) t.stop(); }
    dlog("recording OFF");
  }

  function renderStatsLoop(){renderStats()}
  setInterval(renderStatsLoop, 400);

  btn.addEventListener("click", async () => {
    if (!room) return;
    if (!speaking) {
      try { await startAudio(); }
      catch (err) {
        stateEl.textContent = "mic error";
        dlog("mic error", err?.message || err);
        logLine("[mic] " + (err && err.message ? err.message : err), "final");
      }
    } else {
      stopAudio();
    }
  });

  async function init() {
    await loadConfig();
    createRoom().catch((err) => {
      dlog("createRoom failed", err?.message || err);
      logLine("Gagal membuat room: " + err, "final");
    });
  }

  init();
</script>

</body>
</html>
